<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <title>Socket.IO Ball Animation</title>
    <script src="./node_modules/socket.io/client-dist/socket.io.js"></script>
    <style>
        body, html {
          width:  100%;
          height: 100%;
          margin: 0;
            padding: 0;
            overflow: hidden;
            box-sizing: border-box;
            cursor: none;
        }
        canvas {
          position: absolute;
          top: -15px;
          display: block;      
        }
    </style>
</head>
<body>
    <canvas id="ballCanvas"></canvas>
    <script>
        const socket = io("http://127.0.0.1:3000/");
        const canvas = document.getElementById('ballCanvas');
        const ctx = canvas.getContext('2d');
        let ball = {radius: 10, x: null, y: null, dx: 0, dy: 0, visible: true, velocity: 0};
        let paddle = {height: 10,width: 75,x: null,y: null,direction: null};
        let goal = {width: 100,height: 10};
        let score = { host: 0, client: 0 };

      
        let userRole = '';

        function setupCanvas() {
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight + 15;
            ball.x = canvas.width / 2;
            ball.y = canvas.height / 2;
            paddle.x = (canvas.width - paddle.width) / 2;
            paddle.y = canvas.height - paddle.height;
            if(userRole === 'client') ball.visible = false;
            if (userRole === 'hôte') resetBallPosition();
            animateSetup();
            
        }

        function resetBallPosition() {
            ball.x = canvas.width / 2 - (ball.radius/2);
            ball.y = canvas.height/2 - (ball.radius/2);
            ball.dx = 0;
            ball.dy = 0;
            ball.velocity = 0;
            ball.visible = true;
        }

        function drawBall() {
            if (!ball.visible) return;
            ctx.beginPath();
            ctx.arc(ball.x, ball.y, ball.radius, 0, Math.PI * 2);
            ctx.fillStyle = "#0095DD";
            ctx.fill();
            ctx.closePath();
        }

        function drawPaddle() {
          ctx.beginPath();
          ctx.rect(paddle.x, paddle.y, paddle.width, paddle.height);
          ctx.fillStyle = "#0095DD";
          ctx.shadowColor = '#22282C';
          ctx.shadowBlur = 10;
          ctx.shadowOffsetX = 0;
          ctx.shadowOffsetY = 0;
          ctx.fill();
          ctx.closePath();
      }
      function drawGoals() {
        ctx.beginPath();
        ctx.rect(canvas.width/2 - goal.width/2, canvas.height - goal.height, goal.width, goal.height);
        ctx.fillStyle = "#FFD700";
        ctx.fill();
        ctx.closePath();
    
    }
    function drawScores() {
      ctx.font = "30px Arial";
      ctx.fillStyle = "#FFFFFF";
      ctx.fillText(`Hôte: ${score.host}`, 10, 75); // Positionner le score de l'hôte en haut à gauche
      ctx.fillText(`Vous etes ${userRole}`,canvas.width/2-100, 75); // Positionner le score du client en haut à droite
      ctx.fillText(`Client: ${score.client}`, canvas.width - 140, 75); // Positionner le score du client en haut à droite
  }
  function updateBallPosition() {
    // faire bouger la balle avec la raquette
    console.log(`ball.x: ${ball.x}, ball.y: ${ball.y}, ball.radius: ${ball.radius}, paddle.x: ${paddle.x}, paddle.x max: ${paddle.x + paddle.width} ,paddle.y: ${paddle.y}, paddle.width: ${paddle.width} , paddle.height: ${paddle.height}`)
    
    if(ball.x > paddle.x && ball.x < paddle.x + paddle.width && ball.y + ball.radius > paddle.y && ball.y < paddle.y + paddle.height){
      console.log(true);
      if(ball.dy === 0 && ball.dx === 0){
        ball.velocity = 1;
        ball.dy = -2;
      }else{
        ball.dy = -ball.dy;
        ball.velocity += 0.25;
      }
      ball.dx = 8 * ((ball.x - (paddle.x + paddle.width / 2)) / paddle.width);
    }

    if (ball.y + ball.dy < ball.radius) {
      if (userRole === 'hôte' || userRole === 'client') {
          ball.visible = false;
          sendBallPosition();
          return; // Arrête la mise à jour de la position pour éviter les mouvements inattendus
      }
  }

    ball.x += ball.dx;
    ball.y += ball.dy;
  }
/*  function updateBallPosition() {
    if (!ball.visible) return;
// Démarrez le mouvement de la balle lors de la première collision avec la raquette
 //console.log(ball.dy, ball.dx, ball.y, paddle.y - ball.radius);
if (ball.dy === 0 && ball.dx === 0 && ball.y === paddle.y - ball.radius) {
  console.log(ball.dy, ball.dx, ball.y, paddle.y - ball.radius)
  if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
    ball.velocity = 1; // Réinitialisez la vitesse si nécessaire
      ball.dy =  -2 * ball.velocity; // Définissez les valeurs initiales pour commencer le mouvement
      ball.dx = 8 * ((ball.x - (paddle.x + paddle.width / 2)) / paddle.width);
  }
}

    // Collision avec les bords latéraux du canvas
    if (ball.x + ball.dx > canvas.width - ball.radius || ball.x + ball.dx < ball.radius) {
        ball.dx = -ball.dx;
    }

    // Collision avec la raquette, en prenant en compte la position verticale actuelle de la balle
    if (ball.dy > 0 && ball.y < paddle.y - ball.radius && ball.y + ball.dy >= paddle.y - ball.radius) {
        if (ball.x > paddle.x && ball.x < paddle.x + paddle.width) {
            ball.dy = -ball.dy * ball.velocity; // Inverse la direction verticale de la balle et applique l'accélération
            ball.dx = 8 * ((ball.x - (paddle.x + paddle.width / 2)) / paddle.width); // Applique l'accélération horizontale
            // Pas besoin de réajuster `ball.y` ici car l'ajustement est basé sur la condition de collision
        }
    }

    // Gère la collision avec le haut du canvas ou la transmission de la balle
    if (ball.y + ball.dy < ball.radius) {
        if (userRole === 'hôte' || userRole === 'client') {
            ball.visible = false;
            sendBallPosition();
            return; // Arrête la mise à jour de la position pour éviter les mouvements inattendus
        }
    }

    // Rebond sur le bas du canvas
    if (ball.y + ball.dy > canvas.height - ball.radius) {
      if(ball.x > canvas.width/2 - goal.width/2 && ball.x < canvas.width/2 + goal.width/2){
        if (userRole === 'hôte') {
          score.host++;
          resetBallPosition();
          sendBallPosition();
      } else if (userRole === 'client') {
          score.client++;
          resetBallPosition();
          sendBallPosition();
      }
    }else{
      ball.dy = -ball.dy;
    }
  }

    ball.x += ball.dx;
    ball.y += ball.dy;
}*/
 

        function sendBallPosition() {
            socket.emit('updateBallPosition', {x: ball.x, dx: ball.dx, dy: -ball.dy, velocity: ball.velocity});
        }
        function  animateSetup(){
          ctx.fillStyle = 'rgba(0, 0, 0, 0.4)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            drawBall();
            drawPaddle();
            drawGoals();
            drawScores();
            updateBallPosition();
            requestAnimationFrame(animateSetup);
        }

        document.addEventListener("mousemove", mouseMoveHandler, false);
        function mouseMoveHandler(e) {
          var relativeX = e.clientX - canvas.offsetLeft;
          var relativeY = e.clientY - canvas.offsetTop;
          if (relativeX > 0 && relativeX < canvas.width) {
              paddle.x = relativeX - paddle.width / 2;
          }
          if (relativeY > 0 && relativeY < canvas.height) {
              paddle.y = relativeY - paddle.height / 2;
          }
      }
        window.addEventListener('resize', setupCanvas);
        socket.on('role', (role) => {
            userRole = role;
            setupCanvas();
        });
        socket.on('updateBallPosition', (data) => {
            ball.x = data.x;
            ball.dx = data.dx;
            ball.dy = Math.abs(data.dy);
            ball.velocity = data.velocity;
            ball.y = ball.radius; 
            ball.visible = true;
        });
    </script>
</body>
</html>
